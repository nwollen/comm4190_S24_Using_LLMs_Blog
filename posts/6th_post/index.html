<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Norabug">
<meta name="dcterms.date" content="2024-04-30">
<meta name="description" content="In our class project, we wanted to see if we could tell who’s really the expert in a topic versus just ChatGPT. Let’s see how easy it is to figure out who the real expert is!">

<title>Prompting an Extraordinary LLM - Who’s the True Expert?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Prompting an Extraordinary LLM</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Who’s the True Expert?</h1>
                  <div>
        <div class="description">
          In our class project, we wanted to see if we could tell who’s really the expert in a topic versus just ChatGPT. Let’s see how easy it is to figure out who the real expert is!
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">track</div>
                <div class="quarto-category">basketball</div>
                <div class="quarto-category">consulting</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Norabug </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 30, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-game-of-basketball-the-sport-of-track." class="level1">
<h1>The game of basketball, the sport of track.</h1>
<p><img src="trackbball.png" class="img-fluid"></p>
</section>
<section id="section" class="level1">
<h1></h1>
<p>Reflection: AI, Expertise, and Being Human</p>
<p>We presented two sets of descriptions of track and field events to our classmates, prompting them to discern which one was crafted by a genuine expert and which one was generated by AI. I prompted ChatGPT to try and guess who was the expert and who was not. I copied and pasted an example of my slide, as an expert talking about track, and an example of Jason’s slide talking about track using ChatGPT.</p>
<section id="the-experiment" class="level2">
<h2 class="anchored" data-anchor-id="the-experiment">The Experiment</h2>
<p>Jason prompted ChatGPT to compose a description of track and field events, while I drew upon my own knowledge as a genuine enthusiast of the sport. The goal was twofold: to see if ChatGPT could convincingly mimic expertise, and to spark a discussion about the intersection of AI and human knowledge.</p>
</section>
<section id="the-content" class="level2">
<h2 class="anchored" data-anchor-id="the-content">The Content</h2>
<section id="my-expertise" class="level3">
<h3 class="anchored" data-anchor-id="my-expertise">My Expertise</h3>
<pre><code>- Track is split up into jumps, vault, throws, sprints, hurdles, mid distance, and distance. 
- Jumps consist of high jump, long jump, triple jump, and pole vault. 
- Throws consist of javelin, shot put, hammer throw, and discus
- Sprints consist of 60 (indoor), 100, 200, 300 (indoor), 400
- Hurdles consist of all sprint events except 300
- Mid-D means 800, 1500, 1600 (indoor)
- Distance is 3000 (indoor), 5000, 6000 (cross country), 10000


- Sprint/jump events require more power
- Athletes work on explosiveness, short but heavy loads
- Hurdles works on running through hurdles, mobility, power 
- Throws works on muscle mass
- Lifts very heavy, have to be able to throw something heavy 
- Mid-D is a combination of anaerobic (short and fast) and aerobic (long cardio)
- Distance is all aerobic (continuous running needing oxygen to power)
- Lifting is long reps of light weight
- Pole vault does a lot of gymnastics 

# Reflection: AI, Expertise, and Being Human

We presented two sets of descriptions of track and field events to our classmates, prompting them to discern which one was crafted by a genuine expert and which one was generated by AI. I prompted ChatGPT to try and guess who was the expert and who was not. I copied and pasted an example of my slide, as an expert talking about track, and an example of Jason's slide talking about track using ChatGPT. 

# The Experiment

Jason prompted ChatGPT to compose a description of track and field events, while I drew upon my own knowledge as a genuine enthusiast of the sport. The goal was twofold: to see if ChatGPT could convincingly mimic expertise, and to spark a discussion about the intersection of AI and human knowledge.


# My Expertise 

- Track is split up into jumps, vault, throws, sprints, hurdles, mid distance, and distance. 
- Jumps consist of high jump, long jump, triple jump, and pole vault. 
- Throws consist of javelin, shot put, hammer throw, and discus
- Sprints consist of 60 (indoor), 100, 200, 300 (indoor), 400
- Hurdles consist of all sprint events except 300
- Mid-D means 800, 1500, 1600 (indoor)
- Distance is 3000 (indoor), 5000, 6000 (cross country), 10000


- Sprint/jump events require more power
- Athletes work on explosiveness, short but heavy loads
- Hurdles works on running through hurdles, mobility, power 
- Throws works on muscle mass
- Lifts very heavy, have to be able to throw something heavy 
- Mid-D is a combination of anaerobic (short and fast) and aerobic (long cardio)
- Distance is all aerobic (continuous running needing oxygen to power)
- Lifting is long reps of light weight
- Pole vault does a lot of gymnastics

### Jason's ChatGPT Crafted "Expertise"

- Sprints: These are short-distance races, typically 100 meters, 200 meters, and 400 meters.
- Middle-Distance: Events like the 800 meters and 1500 meters require a balance of speed and endurance.
- Long-Distance: Races such as the 3000 meters, 5000 meters, and 10,000 meters test endurance and pacing abilities.

- Hurdles: Occurs in events like the 100 meters hurdles and the 400 meters hurdles
- Long Jump: Athletes sprint down a runway and jump into a sandpit, aiming for maximum distance.
- Triple Jump: Similar to the long jump but with three phases of jumps (hop, step, jump) before landing in the sandpit.
- High Jump: Athletes jump over a horizontal bar using a technique that involves clearing the bar without knocking it off.
- Pole Vault: Athletes use a pole to vault themselves over a high bar

- Shot Put: Athletes throw a heavy metal ball (the shot) for distance, using a pushing motion.
- Discus Throw: Athletes spin and release a discus, aiming for maximum distance.
- Javelin Throw: Athletes throw a spear-like javelin for distance, using a run-up and specific throwing technique.
- Hammer Throw: Athletes spin and release a heavy hammer attached to a wire, aiming for distance.

# Class Reaction

Generally, the class knew it was me who was the track expert. One person added that they only knew because I walk around in a Penn Track &amp; Field bag. That makes me think that maybe ChatGPT can simulate human expertise. For other classmates' presentations, some people mistakenly thought the ChatGPT created expertise was the true human expertise. 

# Can ChatGPT correctly guess who is the expert and who has used AI?

### I prompted Chat to try and decipher which one of us is the track expert, and which one is not (my track expertise as 1st and Jason's fake ChatGPT expertise as 2nd. Here's what it found...
</code></pre>
<p>“Based on the provided examples, it seems that the first person is Jason and the second person is the real expert. The first person’s description lacks some specificity and depth, using more general terms like ‘work on explosiveness’ and ‘lifts very heavy.’ In contrast, the second person’s description provides specific distances for each type of race, indicating a deeper understanding of track and field events. Additionally, the second person uses terms like ‘balance of speed and endurance’ and ‘tests endurance and pacing abilities,’ which are more indicative of someone with genuine expertise in athletics.”</p>
<p>I broke the news to ChatGPT-</p>
<p>Chat, im sorry to say, but you guessed wrong. I wrote the first section as an expert and the second section was written by Jason using ChatGPT. What do you have to say for yourself?</p>
</section>
</section>
<section id="chats-response-was-as-follows" class="level2">
<h2 class="anchored" data-anchor-id="chats-response-was-as-follows">Chat’s response was as follows…</h2>
<p>“My apologies for the incorrect guess! It seems that Jason’s use of ChatGPT to generate the second section was quite convincing. This highlights the challenge of accurately discerning between genuine expertise and AI-generated content, even for an AI like myself. It’s a testament to the advancements in natural language processing and the potential for AI to simulate human-like responses.</p>
<p>However, it’s also important to acknowledge that while AI can generate content, it may not always capture the depth, nuance, and personal experience that come with genuine human expertise. This experiment underscores the value of human insight and intuition, which can’t be fully replicated by AI.”</p>
<hr>
<p>While our experiment challenged the boundaries between human-generated and AI-generated content, it reaffirmed the truth that expertise is rooted in the depths of human understanding. Despite AI’s ability to simulate human-like responses, there’s an intangible quality to human expertise that can’t be replicated.</p>
<p>ok</p>
</section>
</section>
<section id="reflection-ai-expertise-and-being-human" class="level1">
<h1>Reflection: AI, Expertise, and Being Human</h1>
<p>We presented two sets of descriptions of track and field events to our classmates, prompting them to discern which one was crafted by a genuine expert and which one was generated by AI. I prompted ChatGPT to try and guess who was the expert and who was not. I copied and pasted an example of my slide, as an expert talking about track, and an example of Jason’s slide talking about track using ChatGPT.</p>
<section id="the-experiment-1" class="level2">
<h2 class="anchored" data-anchor-id="the-experiment-1">The Experiment</h2>
<p>Jason prompted ChatGPT to compose a description of track and field events, while I drew upon my own knowledge as a genuine enthusiast of the sport. The goal was twofold: to see if ChatGPT could convincingly mimic expertise, and to spark a discussion about the intersection of AI and human knowledge.</p>
</section>
<section id="my-expertise-1" class="level2">
<h2 class="anchored" data-anchor-id="my-expertise-1">My Expertise</h2>
<ul>
<li>Track is split up into jumps, vault, throws, sprints, hurdles, mid distance, and distance.</li>
<li>Jumps consist of high jump, long jump, triple jump, and pole vault.</li>
<li>Throws consist of javelin, shot put, hammer throw, and discus</li>
<li>Sprints consist of 60 (indoor), 100, 200, 300 (indoor), 400</li>
<li>Hurdles consist of all sprint events except 300</li>
<li>Mid-D means 800, 1500, 1600 (indoor)</li>
<li>Distance is 3000 (indoor), 5000, 6000 (cross country), 10000</li>
</ul>
</section>
<section id="jasons-chatgpt-crafted-expertise" class="level2">
<h2 class="anchored" data-anchor-id="jasons-chatgpt-crafted-expertise">Jason’s ChatGPT Crafted “Expertise”</h2>
<ul>
<li><p>Sprints: These are short-distance races, typically 100 meters, 200 meters, and 400 meters.</p></li>
<li><p>Middle-Distance: Events like the 800 meters and 1500 meters require a balance of speed and endurance.</p></li>
<li><p>Long-Distance: Races such as the 3000 meters, 5000 meters, and 10,000 meters test endurance and pacing abilities.</p></li>
<li><p>Hurdles: Occurs in events like the 100 meters hurdles and the 400 meters hurdles</p></li>
<li><p>Long Jump: Athletes sprint down a runway and jump into a sandpit, aiming for maximum distance.</p></li>
<li><p>Triple Jump: Similar to the long jump but with three phases of jumps (hop, step, jump) before landing in the sandpit.</p></li>
<li><p>High Jump: Athletes jump over a horizontal bar using a technique that involves clearing the bar without knocking it off.</p></li>
<li><p>Pole Vault: Athletes use a pole to vault themselves over a high bar</p></li>
<li><p>Shot Put: Athletes throw a heavy metal ball (the shot) for distance, using a pushing motion.</p></li>
<li><p>Discus Throw: Athletes spin and release a discus, aiming for maximum distance.</p></li>
<li><p>Javelin Throw: Athletes throw a spear-like javelin for distance, using a run-up and specific throwing technique.</p></li>
<li><p>Hammer Throw: Athletes spin and release a heavy hammer attached to a wire, aiming for distance.</p></li>
</ul>
</section>
<section id="class-reaction" class="level2">
<h2 class="anchored" data-anchor-id="class-reaction">Class Reaction</h2>
<p>Generally, the class knew it was me who was the track expert. One person added that they only knew because I walk around in a Penn Track &amp; Field bag. That makes me think that maybe ChatGPT can simulate human expertise. For other classmates’ presentations, some people mistakenly thought the ChatGPT created expertise was the true human expertise.</p>
</section>
<section id="can-chatgpt-correctly-guess-who-is-the-expert-and-who-has-used-ai" class="level2">
<h2 class="anchored" data-anchor-id="can-chatgpt-correctly-guess-who-is-the-expert-and-who-has-used-ai">Can ChatGPT correctly guess who is the expert and who has used AI?</h2>
<section id="i-prompted-chat-to-try-and-decipher-which-one-of-us-is-the-track-expert-and-which-one-is-not-my-track-expertise-as-1st-and-jasons-fake-chatgpt-expertise-as-2nd.-heres-what-it-found" class="level3">
<h3 class="anchored" data-anchor-id="i-prompted-chat-to-try-and-decipher-which-one-of-us-is-the-track-expert-and-which-one-is-not-my-track-expertise-as-1st-and-jasons-fake-chatgpt-expertise-as-2nd.-heres-what-it-found">I prompted Chat to try and decipher which one of us is the track expert, and which one is not (my track expertise as 1st and Jason’s fake ChatGPT expertise as 2nd. Here’s what it found…</h3>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nwollen\.github\.io\/comm4190_S24_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>